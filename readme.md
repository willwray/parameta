# Parameter types for templated models

## C++20 concepts and types for parameterization

<details><summary>Copyright &copy; 2022 Lemurian Labs. Distributed under the Boost Software License, V1.0</summary>

### **Boost Software License** - Version 1.0 - August 17th, 2003

```txt
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
```

[![License](https://img.shields.io/badge/license-boost%201.0-blue.svg)](https://www.boost.org/LICENSE_1_0.txt)

Also at [boost.org](http://www.boost.org/LICENSE_1_0.txt) and accompanying file [LICENSE](LICENSE)

</details>

--------------

**Parameters** are model variables that a system modeler choses to 'freeze'
to be viewed as constants in analysis and design, or in a deployed system.

> Different fields have different definitions of 'parameter'.  
We take a **systems modeling** perspective.

Parameter tuning, being a process that modifies values, appears
incompatible with C++ template parameters that are immutable
compile-time constants.
It turns out that a crack in the template permafrost allows template arguments
to reference global mutable data. We will exploit this feature.

Flexible model development calls for freedom to deal with parameters
dynamically during design,
and then transition to statically compiled values
to be constant-folded into code for release.

# parameta.hpp

This header provides tools to parameterize models for a kind of 'generic staticity';
to select some arguments as dynamic runtime-determined values and others as
static compile-time constants.

The tools leverage C++20 features to enable DSL-like template signatures.

E.g. `std::span` and `mdspan` employ `std::dynamic_extent` as a special value for
the template argument to switch between static and dynamic specializations.
Here, meta types serve this purpose in more generic, uniform and richer ways.

Template class types `pval` and `dval` represent static and dynamic parameter values
in templated interfaces:
  
* `pval<value[,x...]>` : an empty class carrying a static value parameter,  
* `dval<typename[,x...]>` : a class wrapping a value of the given type.  

They have the API of `std::integral_constant`; a no-arg call `operator()()const`  
and implicit conversion to its return type, the `value_type` member type alias.

*  `pval<v[,x]>` generalizes `std::integral_constant<T,v>` compile-time constant,
*  `dval<T[,x]>` represents a dynamic runtime-determined value with a shared API:

```c++
                    value type
                       v
    template <typename T, decltype(auto)...x>
    struct dval;                           ^
                                         ['xtra' optional arg[s]]
                                                v
    template <decltype(auto) v, decltype(auto)...x>
    struct pval;             ^
                    NTTP arg value
```

<details><summary>For comparison, here's the template signature of
<code>std::integral_constant</code><br>
&nbsp;&nbsp;&nbsp;(click for an implementation)</summary>

 https://en.cppreference.com/w/cpp/types/integral_constant

```c++
    template <typename T, T v>   struct integral_constant
    {
      using value_type = T;
      using type = integral_constant;
      static constexpr value_type value = v;
      constexpr operator value_type() const noexcept { return value; }
      constexpr value_type operator()() const noexcept { return value; }
    };
```

</details>

```c++
                  value type
                       v 
    template <typename T, T v>    struct integral_constant;
                            ^
                        NTTP arg value
```

**`pval`** drops `integral_constant`'s explicit first type argument `T` 
leaving the type implicit  
as the type of the value `v`:

```c++
    using value_type = decltype(v); // may be an lvalue reference type
```

The changed template signature, and resulting change in `value_type` defintion are the  
only differences between `pval` and  `integral_constant`, which can then be aliased as:

```c++
    template <typename T, T v> using integral_constant = pval<v>;
```

Note that there are no constraints on the type `T` beyond that in the second parameter `T v`  
it is implicit that it must be usable as the type of a non-type template parameter (NTTP).  
In fact, the name 'integral_constant' only suggests its intended usage;
`T` needn't be integral.  
In particular, lvalue reference types have always been admitted,
which may refer to non-const variables - mutable global data.  
Now, C++20 allows class-type NTTP, with certain 'structural' type restrictions.

`pval`'s value `v` is an NTTP (non-type template parameter, so has to be of structural type).

The leading `decltype(auto)` placeholder directly accepts argument values.  
When passed a object lvalue, of static storage duration, a reference is deduced.  
However, `pval` requires that any reference value is a constant reference

```c++
    float global;              // static mutable global data
    pval< global > oops;       // COMPILE FAIL, C++: value is not constexpr
    pval<(global)> wrong;      // requirement FAIL: reference to mutable

    pval<as_const(global)> gc; // deduces value_type = float const&
```

